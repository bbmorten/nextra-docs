# Learning Next.js - Reboot 

Code name is nextjs-f-v2.

Starts with the reading of https://nextjs.org/docs/app/getting-started

Prerequisites:

- https://nextjs.org/learn/react-foundations


## React foundations

https://nextjs.org/learn/react-foundations/what-is-react-and-nextjs#building-blocks-of-a-web-application



## 2025-10-20

###  Next.js learning

#### Reorganized projects


/Users/bulent/git-msp/javascript 

This folder includes samples applications for javascript language. 

- Use copilot to create a new project.
- tasks.json starts the web server automatically. 

/Users/bulent/git-msp/javascript/.github/instructions/new-project.instructions.md
/Users/bulent/git-msp/javascript/.vscode/tasks.json


#### Project Notes

##### Project: [nextra-docs](/Users/bulent/git-msp/nextra-docs)

- No content

##### Project: [nextjs-f-v2](docs/nextjs-f-v2.mdx)

- Located at /Users/bulent/git-msp/nextjs-f-v2
- This project is for learning next.js features and functionalities.

##### Project: [javascript](/Users/bulent/git-msp/javascript)


**DOM: createTextNode and createElement**

A compact reference and examples for creating DOM nodes programmatically.

- document.createElement(tagName): creates an element node (div, span, button, etc.).
- document.createTextNode(text): creates a text node. Useful when you need a node that contains only text (and want to avoid parsing HTML).
- element.textContent = '...': simpler alternative for adding plain text to an element.
- innerHTML: parses HTML (use carefully — XSS risk).

When to use which:
- Use createElement when you need to build element structure or attach attributes/events.
- Use textContent or createTextNode for inserting plain text. textContent is usually simpler.
- Use innerHTML only when you intentionally need HTML parsing.

Examples

Basic element + text node:

**Developer Tools**

- Use DOM tree and "Scroll into view"

![scrollintoview](/assets/images/scrollintoview.png)

- $0

![$0.textContent](/assets/images/$0.png)



## 2025-10-29

### JS ES6 Modules

/Users/bulent/git-msp/javascript/js-samples/module/

✅ Clean JavaScript Code
What it does:

Displays a simple message: "Hello from Module project!" in the result div
Extracts the HTML comment: Uses regex to find the first HTML comment in the page
Creates a styled div: Displays the comment content in a nicely formatted box
Proper structure: Clean, readable code with clear comments
Key functions:

displayCommentAsDiv() - Main function that handles the extraction and display
Clean styling with proper CSS
Error handling for cases where no comment is found

### JavaScript Module Patterns: Four Approaches Compared

#### 1. ES6 Modules (Script Type="module")
The modern standard for JavaScript modules, using `import` and `export` statements with `<script type="module">`. Provides true module scope, automatic strict mode, and deferred execution. Requires a web server to function due to CORS restrictions, but offers the cleanest syntax and best browser optimization.

```javascript
// math.js
export function add(x, y) { return x + y; }

// main.js
import { add } from './math.js';
```

#### 2. IIFE Pattern (Immediately Invoked Function Expression)
Creates module-like encapsulation by wrapping code in a function that executes immediately. Variables and functions inside the IIFE are private by default, with selective exposure through returned objects or global assignment. Works in any JavaScript environment without requiring ES6 support.

```javascript
(function() {
    var privateVar = 'hidden';
    var ModuleApp = {
        publicMethod: function() { /* uses privateVar */ }
    };
    window.ModuleApp = ModuleApp;
})();
```

#### 3. Global Object Pattern (Namespace Pattern)
Organizes code into a single global namespace object to prevent global scope pollution. Multiple script files can extend the same namespace, making it easy to share functionality across files. All properties are public, but the structured approach prevents naming conflicts.

```javascript
var MyNamespace = MyNamespace || {};
MyNamespace.Utils = { /* utility functions */ };
MyNamespace.UI = { /* interface methods */ };
```

#### 4. Revealing Module Pattern
Uses closures to create true privacy while exposing a clean, explicit public API. All variables and functions are private by default, with only explicitly returned methods becoming public. Provides the clearest separation between private implementation and public interface.

```javascript
var RevealingModule = (function() {
    var privateVar = 'secret';
    function privateFunction() { /* internal logic */ }
    
    return {
        publicMethod: privateFunction,
        publicProperty: 'exposed'
    };
})();
```

