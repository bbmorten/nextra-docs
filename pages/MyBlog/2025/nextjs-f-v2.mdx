# Learning Next.js - Reboot 

Code name is nextjs-f-v2.

Starts with the reading of https://nextjs.org/docs/app/getting-started

Prerequisites:

- https://nextjs.org/learn/react-foundations


## React foundations

https://nextjs.org/learn/react-foundations/what-is-react-and-nextjs#building-blocks-of-a-web-application



## 2025-10-20

###  Next.js learning

#### Reorganized projects


/Users/bulent/git-msp/javascript 

This folder includes samples applications for javascript language. 

- Use copilot to create a new project.
- tasks.json starts the web server automatically. 

/Users/bulent/git-msp/javascript/.github/instructions/new-project.instructions.md
/Users/bulent/git-msp/javascript/.vscode/tasks.json


#### Project Notes

##### Project: [nextra-docs](/Users/bulent/git-msp/nextra-docs)

- No content

##### Project: [nextjs-f-v2](docs/nextjs-f-v2.mdx)

- Located at /Users/bulent/git-msp/nextjs-f-v2
- This project is for learning next.js features and functionalities.

##### Project: [javascript](/Users/bulent/git-msp/javascript)


**DOM: createTextNode and createElement**

A compact reference and examples for creating DOM nodes programmatically.

- document.createElement(tagName): creates an element node (div, span, button, etc.).
- document.createTextNode(text): creates a text node. Useful when you need a node that contains only text (and want to avoid parsing HTML).
- element.textContent = '...': simpler alternative for adding plain text to an element.
- innerHTML: parses HTML (use carefully — XSS risk).

When to use which:
- Use createElement when you need to build element structure or attach attributes/events.
- Use textContent or createTextNode for inserting plain text. textContent is usually simpler.
- Use innerHTML only when you intentionally need HTML parsing.

Examples

Basic element + text node:

**Developer Tools**

- Use DOM tree and "Scroll into view"

![scrollintoview](/assets/images/scrollintoview.png)

- $0

![$0.textContent](/assets/images/$0.png)



## 2025-10-29

### JS ES6 Modules

/Users/bulent/git-msp/javascript/js-samples/module/

✅ Clean JavaScript Code
What it does:

Displays a simple message: "Hello from Module project!" in the result div
Extracts the HTML comment: Uses regex to find the first HTML comment in the page
Creates a styled div: Displays the comment content in a nicely formatted box
Proper structure: Clean, readable code with clear comments
Key functions:

displayCommentAsDiv() - Main function that handles the extraction and display
Clean styling with proper CSS
Error handling for cases where no comment is found

### JavaScript Module Patterns: Four Approaches Compared

#### 1. ES6 Modules (Script Type="module")
The modern standard for JavaScript modules, using `import` and `export` statements with `<script type="module">`. Provides true module scope, automatic strict mode, and deferred execution. Requires a web server to function due to CORS restrictions, but offers the cleanest syntax and best browser optimization.

```javascript
// math.js
export function add(x, y) { return x + y; }

// main.js
import { add } from './math.js';
```

#### 2. IIFE Pattern (Immediately Invoked Function Expression)
Creates module-like encapsulation by wrapping code in a function that executes immediately. Variables and functions inside the IIFE are private by default, with selective exposure through returned objects or global assignment. Works in any JavaScript environment without requiring ES6 support.

```javascript
(function() {
    var privateVar = 'hidden';
    var ModuleApp = {
        publicMethod: function() { /* uses privateVar */ }
    };
    window.ModuleApp = ModuleApp;
})();
```

#### 3. Global Object Pattern (Namespace Pattern)
Organizes code into a single global namespace object to prevent global scope pollution. Multiple script files can extend the same namespace, making it easy to share functionality across files. All properties are public, but the structured approach prevents naming conflicts.

```javascript
var MyNamespace = MyNamespace || {};
MyNamespace.Utils = { /* utility functions */ };
MyNamespace.UI = { /* interface methods */ };
```

#### 4. Revealing Module Pattern
Uses closures to create true privacy while exposing a clean, explicit public API. All variables and functions are private by default, with only explicitly returned methods becoming public. Provides the clearest separation between private implementation and public interface.

```javascript
var RevealingModule = (function() {
    var privateVar = 'secret';
    function privateFunction() { /* internal logic */ }
    
    return {
        publicMethod: privateFunction,
        publicProperty: 'exposed'
    };
})();
```

## 2025-11-01 

### https://nextjs.org/learn/react-foundations/updating-ui-with-javascript#imperative-vs-declarative-programming

### Imperative vs Declarative Programming
- Imperative programming focuses on how to perform tasks step-by-step, specifying the exact commands to change the program's state.
- Declarative programming focuses on what the desired outcome is, allowing the underlying system to determine how
to achieve it.
- React and Next.js promote declarative programming, where you describe the UI state and let the framework handle updates.
#### Example Comparison
**Imperative Approach:**
```javascript
const button = document.getElementById('myButton');
button.addEventListener('click', () => {
    const list = document.getElementById('myList');
    const newItem = document.createElement('li');
    newItem.textContent = 'New Item';
    list.appendChild(newItem);
});
```
**Declarative Approach with React:**
```javascript
import { useState } from 'react';   
function MyComponent() {
    const [items, setItems] = useState([]);
    return (
        <>
            <button onClick={() => setItems([...items, 'New Item'])}>
                Add Item
            </button>
            <ul>
                {items.map((item, index) => (
                    <li key={index}>{item}</li>
                ))}
            </ul>
        </>
    );
}
``` 

- react-01 example is added to js-samples/react-01 folder.


### Origin

https://developer.mozilla.org/en-US/docs/Glossary/Origin


An origin is defined by the scheme (protocol), host (domain), and port of a URL. Two URLs have the same origin if all three components are identical.
For example, the URLs `https://example.com:443/page1` and `https://example.com:443/page2` share the same origin because they have the same scheme (`https`), host (`example.com`), and port (`443`). However, `http://example.com/page1` has a different origin due to the different scheme (`http` vs. `https`).
### Same-Origin Policy
The same-origin policy is a critical security mechanism that restricts how documents or scripts loaded from one
origin can interact with resources from another origin. This policy helps prevent malicious scripts on one page from accessing sensitive data on another page through the browser.
### Cross-Origin Resource Sharing (CORS)
CORS is a mechanism that allows controlled access to resources located outside of a given domain. It uses HTTP headers to specify which origins are permitted to access resources on a server, enabling secure cross-origin requests.
### Example of CORS Headers
```http 
Access-Control-Allow-Origin: https://example.com
Access-Control-Allow-Methods: GET, POST, OPTIONS
Access-Control-Allow-Headers: Content-Type
```
### Practical Implications
- Web applications must adhere to the same-origin policy to ensure security.
- CORS headers must be properly configured on servers to allow legitimate cross-origin requests.
### Additional Resources
- [MDN Web Docs: Same-Origin Policy](https://developer.mozilla.org/en-US/docs/Web/Security/Same-origin_policy)
- [MDN Web Docs: CORS](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS)

### CORS and ES6 Modules
ES6 modules enforce CORS restrictions, meaning they must be served from a web server rather than being opened directly from the file system. This is to ensure that module imports adhere to the same-origin policy and maintain security.
When using ES6 modules, attempting to load them directly from the `file://` protocol will result in errors due to CORS violations. To work around this, developers should serve their modules via a local development server or any HTTP server. Here are some common methods to serve ES6 modules:
- **Using a Simple HTTP Server**: You can use Python's built-in HTTP server or Node.js-based servers like `http-server` or `live-server`.
- **Development Tools**: Many IDEs and code editors offer extensions or built-in features to serve files over HTTP for development purposes.
By adhering to these practices, developers can effectively utilize ES6 modules while complying with CORS requirements.

### Summary
- An origin consists of the scheme, host, and port of a URL.
- The same-origin policy restricts interactions between resources from different origins for security.
- CORS allows controlled cross-origin requests through specific HTTP headers.
- ES6 modules must be served from a web server to comply with CORS restrictions.

### React.Fragment


I notice there's a discrepancy between your project context and the code selection. You mentioned you're working on a JavaScript/npm project, and the provided files show pure JavaScript examples using ES6 modules and DOM manipulation. However, the active selection shows React code:

```javascript
React.createElement(React.Fragment, null,
```

This line is creating a React Fragment element using React's `createElement` API. `React.Fragment` is a special React component that allows you to group multiple child elements without adding an extra DOM node to the rendered output. It's essentially an invisible wrapper.

The `createElement` function takes three parameters:
1. `React.Fragment` - the component type (in this case, a Fragment)
2. `null` - the props object (Fragment doesn't need any props, so it's null)
3. The third parameter (not shown in your selection) would be the child elements

This is the JavaScript equivalent of using the JSX shorthand `<>...</>` or `<React.Fragment>...</React.Fragment>`. When you write JSX, it gets transpiled to these `createElement` calls.

However, this React code doesn't align with your project structure, which appears to be focused on vanilla JavaScript examples without build tools. Could you clarify if you meant to select different code, or if you're planning to add React examples to your JavaScript learning samples?
```javascript
React.createElement(React.Fragment, null,
```

This line is creating a React Fragment element using React's `createElement` API. `React.Fragment` is a special React component that allows you to group multiple child elements without adding an extra DOM node to the rendered output. It's essentially an invisible wrapper.

The `createElement` function takes three parameters:
1. `React.Fragment` - the component type (in this case, a Fragment)
2. `null` - the props object (Fragment doesn't need any props, so it's null)
3. The third parameter (not shown in your selection) would be the child elements

This is the JavaScript equivalent of using the JSX shorthand `<>...</>` or `<React.Fragment>...</React.Fragment>`. When you write JSX, it gets transpiled to these `createElement` calls.

However, this React code doesn't align with your project structure, which appears to be focused on vanilla JavaScript examples without build tools. Could you clarify if you meant to select different code, or if you're planning to add React examples to your JavaScript learning samples?


### JSX

https://react.dev/learn/writing-markup-with-jsx#the-rules-of-jsx

JSX is a syntax extension for JavaScript that looks similar to XML or HTML. It is used in React to describe what the UI should look like. JSX allows you to write HTML-like code within JavaScript, making it easier to visualize the structure of your components.
