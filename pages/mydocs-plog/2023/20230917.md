# 20230917 Docker, Jenkins

## docker

## Docker Engine in Docker Desktop (ChatGPT)

As of my last update in September 2021, Docker Desktop for macOS doesn't expose the Docker Remote API over TCP by default, and enabling it requires some workarounds. This is because Docker Desktop for macOS runs containers in a Linux VM, and by default, the Docker daemon inside this VM is only accessible from the host machine (your Mac).

Here are some common methods to make the Docker Remote API accessible from a container:

### Using Docker-in-Docker (DinD)

One approach to make the Docker API accessible from within a container is to use Docker-in-Docker. By doing so, you can run a Docker daemon inside a Docker container. The official `docker:dind` image can be used for this purpose.

Here's a simple Docker Compose example:

```yaml
version: "3"
services:
  docker-dind:
    image: docker:dind
    privileged: true
    ports:
      - "2376:2376"
```

In this setup, the Docker daemon in the `docker-dind` container will be accessible from other containers at `docker-dind:2376`.

However, this approach has some downsides, such as security concerns and potentially complex configuration.

### Mounting the Docker Socket

Another common method is to mount the Docker socket from the host into a container. This way, the container can communicate directly with the Docker daemon on the host.

Here's how you can do it with Docker Compose:

```yaml
version: "3"
services:
  docker-client:
    image: docker  # or any other image that has the Docker CLI installed
    volumes:
      - /var/run/docker.sock:/var/run/docker.sock
```

Note that this also has some security implications, as the container has full control over Docker on the host machine.

### Network Bridge

You can create a special network bridge that includes your container and the host, but this is more complex and involves configuring IP routing.

Keep in mind that enabling external access to your Docker daemon without proper security measures (TLS, firewall rules, etc.) is a security risk.

Before proceeding with any of these methods, read the [official Docker documentation](https://docs.docker.com/engine/security/https/) for best practices on securing the Docker daemon.


##  Accessing Docker Engine API over sending HTTP request over unix-socket

```console
curl --unix-socket /var/run/docker.sock -H "Content-Type: application/json" \
  -d '{"Image": "alpine", "Cmd": ["echo", "hello world"]}' \
  -X POST http://localhost/v1.43/containers/create

```



### Docker Dashboard with Node.js Express, Docker API

Container listesini EJS modülü ile HTML tablo olarak veren basit bir express uygulaması

```console
node index.js
```

Docker compose file'da ok ancak container'ın hostun docker processine bağlanmasının çözülmesi lazım.

/Users/bulent/git-repos/docker-dashboard-w-express/README.md

## templates

~/git-repos/docker-v3-repos altında templateler yaratıldı.

- jenkins
- mongodb and mongoexpress



###  Stopping services started by docker compose

Find the project folders and compose file locations with ***docker compose ls***

```shell
vm@int-isnet-01:~$ docker compose ls
NAME                STATUS              CONFIG FILES
docker-v3           running(1)          /home/vm/coursefiles/docker-v3/docker-compose.yml
mongodb             running(2)          /home/vm/coursefiles/containers/mongodb/docker-compose.yml
vm@int-isnet-01:~$ docker compose -f /home/vm/coursefiles/docker-v3/docker-compose.yml down
[+] Running 2/2
 ✔ Container docker-v3-docs-1  Removed                                                      10.3s 
 ✔ Network docker-v3_default   Removed   
```

### Stopping services started by docker compose with a shell script (TESTED OK)

```bash
#!/bin/bash

# Get the list of running Docker Compose projects
projects=$(docker compose ls | awk 'NR>1 {print $1}')

# Loop through each project and run `docker compose down`
for project in $projects; do
  echo "Stopping project $project..."
  docker compose -p $project down
done
```

###  Shell script running all docker compose projects (TESTED OK)

```bash
#!/bin/bash

# Define the base directory where your Docker Compose project folders are stored
BASE_DIR=~/git-repos

# Loop through each project name passed as an argument to the script
for project in "$@"; do
  project_dir="$BASE_DIR/$project"

  # Check if the project directory exists
  if [ -d "$project_dir" ]; then
    # Check if a docker-compose.yml file exists in the project directory
    if [ -f "$project_dir/docker-compose.yml" ]; then
      echo "Starting project $project..."
      # Run the docker compose up command in detached mode to start the project in the background
      docker compose -f "$project_dir/docker-compose.yml" up -d
    else
      echo "Warning: No docker-compose.yml file found in $project_dir."
    fi
  else
    echo "Warning: Directory $project_dir does not exist."
  fi
done
```

##  Shell

###  Listing directory names only

```shell
ls -ld ~git-repos/*

```

##  Jenkins Docker sample

mkdir -p ~git-repos/jenkins-mine/jenkins-home
sudo chown -R 1000:1000 ~git-repos/jenkins-mine/jenkins_home
cd ~git-repos/jenkins_mine
 docker run  -d -p 8080:8080 -p 50000:50000 -v ./jenkins_home:/var/jenkins_home jenkins
