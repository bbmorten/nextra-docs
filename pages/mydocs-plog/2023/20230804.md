# 20230804 - TypeScript Cookbook

I've encountered the site [MakeCode](https://www.microsoft.com/en-us/makecode?rtc=1)

[Naming conventions](https://makecode.com/extensions/naming-conventions#:~:text=TypeScript%20conventions%201%20API%20and%20function%20names%20are,Class%2C%20enums%20and%20enum%20members%20are%20capitalized.%20) for programming typescript and probably the others

##  TypeScript Cookbook Module 2 continues

### Understanding Interfaces vs Type Aliases

There are two different ways in TypeScript to declare object types: Interfaces and type aliases. Which one should you use?

Use type aliases for types within your project’s boundary, and use interfaces for contracts that are meant to be consumed by others.

```typescript
// Step 1: Define the PersonAsType type alias
type PersonAsType = {
  name: string;
  age: number;
  address: string[];
  greet(): string;
};

// Step 2: Create a function to instantiate a new person
function createNewPerson(name: string, age: number, address: string[]): PersonAsType {
  return {
    name,
    age,
    address,
    greet() {
      return `Hello, my name is ${this.name} and I am ${this.age} years old.`;
    }
  };
}

// Step 3: Create a new person
const newPerson = createNewPerson("John Doe", 30, ["123 Main St", "City"], );

// Step 4: Use the created person object
console.log(newPerson.greet()); // Output: "Hello, my name is John Doe and I am 30 years old."
console.log(newPerson.name);    // Output: "John Doe"
console.log(newPerson.age);     // Output: 30
console.log(newPerson.address); // Output: ["123 Main St", "City"]

const newPerson2 : PersonAsType = { name: "Bülent", age : 52, address : ["34485", "Sarıyer","Şişli"], greet() {
      return `Hello, my name is ${this.name} and I am ${this.age} years old.`;
    }}

console.log(newPerson2.greet()); // Output: "Hello, my name is John Doe and I am 30 years old."
console.log(newPerson2.name);    // Output: "John Doe"
console.log(newPerson2.age);     // Output: 30
console.log(newPerson2.address); // Output: ["123 Main St", "City"]


// Interface

// Define the interface in two steps

interface PersonAsInterface {
  name: string;
  age: number;
}

interface PersonAsInterface {
  address: string[];
  greet(): string;
}


class CNewPerson implements PersonAsInterface {
  name: string;
  age: number;
  address: string[];

  constructor(name: string, age: number, address: string[]) {
    this.name = name;
    this.age = age;
    this.address = address;
  }

  greet(): string {
    return `Hello, my name is ${this.name} and I am ${this.age} years old.`;
  }
}

// Create a new person using the NewPerson class
const newPerson3 = new CNewPerson("John Doe", 30, ["123 Main St", "City"]);

// Use the created person object
console.log(newPerson3.greet()); // Output: "Hello, my name is John Doe and I am 30 years old."
console.log(newPerson3.name);    // Output: "John Doe"
console.log(newPerson3.age);     // Output: 30
console.log(newPerson3.address); // Output: ["123 Main St", "City"]

```

### Defining Function Overloads

!!! note "Problem"

    Your function’s API is very flexible and allows for arguments of various types, where context is important. This is hard to type in just a single function signature.

!!! note "Solution"

    Use function overloads.

```typescript
type CallbackFn = () => void;

// Types for the type system
function task(name: string, dependencies: string[]): void;
function task(name: string, callback: CallbackFn): void;
function task(name: string, dependencies: string[], callback: CallbackFn): void;
// The actual implementation
function task(
  name: string,
  param2: string[] | CallbackFn,
  param3?: CallbackFn
): void {
  //...
}

function fn(input: number): number;
function fn(input: string): string;
function fn(input: number | string): number | string {
  if (typeof input === "number") {
    return "this also works";
  } else {
    return 1337;
  }
}

const typeSaysNumberButItsAString = fn(12);
const typeSaysStringButItsANumber = fn("Hello world");

console.log(typeSaysNumberButItsAString);
console.log(typeSaysStringButItsANumber);

type TaskFn = {
  (name: string, dependencies: string[]): void;
  (name: string, callback: CallbackFn): void;
  (name: string, dependencies: string[], callback: CallbackFn): void;
};

function fenasi(input: TaskFn) {
  if (typeof input === "number") {
    return "this also works";
  } else {
    return 1337;
  }
}

const typeSaysNumberButItsAString2 = fenasi(12);
const typeSaysStringButItsANumber2 = fenasi("Hello world");

console.log(typeSaysNumberButItsAString2);
console.log(typeSaysStringButItsANumber2);

```

### Defining this Parameter Types

!!! warning "**this** is different"

  Especially if your background is a class-based object-oriented programming language, where this always refers to an instance of a class. this in JavaScript is entirely different, but not necessarily harder to understand. What’s, even more, is that TypeScript can greatly help us get more closure about this in usage.

  this lives within the scope of a function, and that points to an object or value that is bound to that function. In regular objects, this is pretty straightforward.

```typescript
const authorX = {
  name: "Stefan",
  // function shorthand
  hi() {
    console.log(this.name);
  },
};

authorX.hi(); // prints 'Stefan'

console.log(typeof authorX)


// this 

const authorY = {
  name: "Stefan",
};

function hi() {
  console.log(this.name);
}

const pet = {
  name: "Finni",
  kind: "Cat",
};

// Function apply and call and bind

hi.apply(pet); // prints "Finni"
hi.call(authorY); // prints "Stefan"

const boundHi = hi.bind(authorY);

boundHi(); // prints "Stefan"
```

It doesn’t help that the semantics of this change again if you use arrow functions instead of regular functions.

```typescript
class Person {
  constructor(name) {
    this.name = name;
  }

  hi() {
    console.log(this.name);
  }

  hi_timeout() {
    setTimeout(function() {
      console.log(this.name);
    }, 0);
  }

  hi_timeout_arrow() {
    setTimeout(() => {
      console.log(this.name);
    }, 0);
  }
}

const person = new Person("Stefan")
person.hi(); // prints "Stefan"
person.hi_timeout(); // prints "undefined"
person.hi_timeout_arrow(); // prints "Stefan"
```

Calculator yapalım dedik ama tam olmadı. Sonra bakılabilir. 

