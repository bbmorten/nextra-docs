# 20230805 - TypeScript Cookbook

##  TypeScript Cookbook Module 2 continues

Module 2 bitti burada ancak kodlar biraz dağınık kaldı. Bazılarını notlara ekledim.

(/Users/bulent/git-repos/typescript-ws/my-ts-course-2)

Javascript'e dönmeye karar verdim. Bu kursla şansımı deneyeceğim eğer canım sıkılmazsa 

[Modern Javascript from the Beginning ...
](https://learning.oreilly.com/videos/modern-javascript-from/9781805127826/9781805127826-video1_1/)

### 2.8 Working with Symbols

In JavaScript and TypeScript, square brackets are used to define computed property names. Computed property names allow you to use an expression, including variables and symbols, as the property key when defining an object.

In the given code, `[print]: function() { ... }`, square brackets are used to define a computed property name with the `print` symbol. The `print` symbol is evaluated as the property key, and the associated value is the function expression defined after the colon (`:`).

Using square brackets with computed property names is useful when you want to dynamically define object properties based on some condition or value. In this case, the use of a symbol as the property key ensures that the method is not accidentally overwritten or accessed directly through the object itself, providing a level of privacy for the `print` method.

```typescript
// From Typescript Cookbook Module 2.8

const TITLE1 = Symbol("TITLE");
const TITLE2 = Symbol("TITLE");

console.log(TITLE1 === TITLE2 ? true : false);
console.log(TITLE1.toString() === TITLE2.toString() ? true : false);

console.log(TITLE1.description);
console.log(TITLE1.toString());
console.log(TITLE1.toString);

console.log(TITLE1);

console.log(TITLE1 == "TITLE" ? true : false);

const userX = {
    name : 'Bülent',
    age : 52,
    greet : function () {
        console.log (`Name is ${this.name} and age is ${this.age}`);
    }
}

userX.greet()



const printLabel = Symbol('print')


const userY = {
  name: "Bülent",
  age: 52,
  [printLabel]: function () {
    console.log(`Name is ${this.name} and age is ${this.age}`);
  },
};

// Symbols also work as property keys but are not iterable, which is great for serialization
// stringify shows it

const jUserY =  JSON.stringify(userY)
console.log(jUserY)

userY[printLabel]()

// Computed property name example
function getPropertyKey() {
  return "dynamicKey";
}

const dynamicKey = "age";
const userZ = {
  name: "John",
  [dynamicKey]: 30, // Using a variable to compute the property name
  [getPropertyKey()]: "some value", // Using a function to compute the property name
};

console.log(userZ.name); // Output: "John"
console.log(userZ.age); // Output: 30 (Property name computed using the value of the `dynamicKey` variable)
console.log(userZ.dynamicKey); // Output: undefined (Property name is not "dynamicKey", but rather the value of `dynamicKey`)
console.log(userZ[getPropertyKey()]); // Output: "some value" (Property name computed using the result of the `getPropertyKey()` function)

console.log(userZ)



// The first call to Symbol.for creates a symbol, the second call uses the same symbol. If you store the symbol value in a variable and want to know the key, you can use Symbol.keyFor()

Symbol.for("print"); // creates a global symbol

const userW = {
  name: "Stefan",
  age: 37,
  // uses the global symbol
  [Symbol.for("print")]: function () {
    console.log(`${this.name} is ${this.age} years old`);
  },
};


const privateData = Symbol('privateData');

class MyClass {
  private [privateData]: string;

  constructor(data: string) {
    this[privateData] = data;
  }

  public getData(): string {
    return this[privateData];
  }

}

// Symbols are not truly private, but they provide a form of "name-hiding." They make it less likely for properties to be accidentally overwritten or accessed directly. However, if someone has access to the object, they can still access the Symbol properties.


const objS = new MyClass('secret data');
console.log(objS.getData()); // Output: "secret data"
// secret data is the output
console.log(objS[privateData]); // Output: Error (Symbol not accessible from outside)


const person1 = {
  name: "John",
  age: 30,
  gender: "male",
};

const student = {
  name: "Alice",
  age: 20,
  address: {
    city: "New York",
    street: "123 Main St",
  },
};



const usedSymbolKeys : any = []

function extendObject(obj : any, sym: symbol, value : any) {
  //Oh, what symbol is this?
  const key = Symbol.keyFor(sym)
  //Alright, let's better store this
  if(!usedSymbolKeys.includes(key)) {
    usedSymbolKeys.push(key)
  }
  obj[sym] = value
}

extendObject(person1, Symbol.for('key1'), 'First Person' )
extendObject(person1, Symbol.for("key2"), "Second Person");
extendObject(student, Symbol.for("key1"), "First Student");


// now it's time to retreive them all
function printAllValues(obj) {
  usedSymbolKeys.forEach(key => {
    console.log(obj[Symbol.for(key)]);
  })}

printAllValues(person1)
console.log(usedSymbolKeys)

console.log(person1)
console.log(student);


const sym = Symbol('foo')

function extendObject2(obj: any, sym: symbol, value: any) {
  obj[sym] = value
}

extendObject2({}, sym, 42) // Works with all symbols
```

###  Symbol Examples

Symbols have several practical usages in TypeScript and JavaScript, primarily because they provide a way to create unique and non-enumerable properties in objects. Here are some practical use cases for Symbols in TypeScript:

1. **Private Properties and Methods:**
Symbols can be used to emulate private properties and methods in TypeScript. Since symbols are not exposed through the object's keys, they are not easily accessible from outside the object, providing a form of encapsulation. This helps in keeping the internal implementation details hidden.

```typescript
const privateData = Symbol('privateData');

class MyClass {
  private [privateData]: string;

  constructor(data: string) {
    this[privateData] = data;
  }

  public getData(): string {
    return this[privateData];
  }
}

const obj = new MyClass('secret data');
console.log(obj.getData()); // Output: "secret data"
console.log(obj[privateData]); // Output: Error (Symbol not accessible from outside)
```

2. **Custom Property Keys:**
Symbols can be used to define custom property keys for special behaviors or meta-information in an object. Since symbols are unique, they won't conflict with other property names.

```typescript
const specialProperty = Symbol('specialProperty');

const myObj = {
  [specialProperty]: "This is a special property.",
  regularProperty: "This is a regular property.",
};

console.log(myObj.regularProperty); // Output: "This is a regular property."
console.log(myObj[specialProperty]); // Output: "This is a special property."
```

3. **Iterating Over Properties:**
Symbols can be used to add non-enumerable properties that won't be included when iterating over object keys using methods like `for...in` or `Object.keys()`.

```typescript
const nonEnumerableProperty = Symbol('nonEnumerableProperty');

const myObj = {
  name: 'John',
  age: 30,
  [nonEnumerableProperty]: 'This is a non-enumerable property.',
};

for (const key in myObj) {
  console.log(key); // Output: "name", "age" (nonEnumerableProperty is not visible)
}

console.log(Object.keys(myObj)); // Output: ["name", "age"] (nonEnumerableProperty is not included)
```

4. **Avoiding Property Name Collisions:**
Symbols can be used to define properties in objects to avoid accidental property name collisions, especially in cases where different parts of the codebase may want to define properties with the same name but different meanings.

```typescript
const MODULE_A = Symbol('MODULE_A');
const MODULE_B = Symbol('MODULE_B');

const myApp = {
  [MODULE_A]: 'Data for module A',
  [MODULE_B]: 'Data for module B',
};

console.log(myApp[MODULE_A]); // Output: "Data for module A"
console.log(myApp[MODULE_B]); // Output: "Data for module B"
```

Remember that symbols are not completely private; they can still be accessed through reflection techniques like `Object.getOwnPropertySymbols()` or `Reflect.ownKeys()`. However, they provide a level of abstraction and encapsulation, making the codebase more maintainable and robust.

### Examples of objects

Sure! Here are some examples of objects in TypeScript:

1. **Basic Object:**

```typescript
const person = {
  name: "John",
  age: 30,
  gender: "male",
};
```

2. **Nested Object:**

```typescript
const student = {
  name: "Alice",
  age: 20,
  address: {
    city: "New York",
    street: "123 Main St",
  },
};
```

3. **Object with Functions (Methods):**

```typescript
const calculator = {
  add: (a: number, b: number) => a + b,
  subtract: (a: number, b: number) => a - b,
  multiply: (a: number, b: number) => a * b,
};
```

4. **Object with Computed Properties:**

```typescript
const propName = "color";
const car = {
  make: "Toyota",
  model: "Camry",
  [propName]: "blue",
};
```

5. **Object with Symbol Properties:**

```typescript
const mySymbol = Symbol("mySymbol");
const objWithSymbol = {
  name: "Jane",
  age: 25,
  [mySymbol]: "This is a symbol property.",
};
```

6. **Object with Methods:**

```typescript
class Dog {
  constructor(public name: string) {}

  bark(): void {
    console.log("Woof!");
  }
}

const myDog = new Dog("Buddy");
myDog.bark(); // Output: "Woof!"
```

7. **Object with Generic Types:**

```typescript
interface Pair<T> {
  first: T;
  second: T;
}

const numberPair: Pair<number> = { first: 10, second: 20 };
const stringPair: Pair<string> = { first: "hello", second: "world" };
```

8. **Object with Union Types:**

```typescript
interface Cat {
  name: string;
  meow: () => void;
}

interface Dog {
  name: string;
  bark: () => void;
}

const pet: Cat | Dog = {
  name: "Fluffy",
  meow: () => console.log("Meow!"),
  // OR
  // bark: () => console.log("Woof!")
};
```

These are just a few examples of objects in TypeScript. Objects are a fundamental data structure that allows you to organize and store data in key-value pairs, making them versatile and widely used in TypeScript applications.

### Nominal Types in Javascript means what for typescript

The sentence refers to the concept of "nominal types" in TypeScript and its relation to "nominal values" in JavaScript.

In TypeScript, a "nominal type" is a user-defined type that is distinct from other types, even if their structures are identical. It allows you to create types that have the same shape but are considered different types by the TypeScript compiler. This helps in preventing unintended type mixing and provides better type safety.

On the other hand, the term "nominal value" in JavaScript generally means a value that has a unique and distinct identity. In JavaScript, primitive values like strings and numbers are considered nominal because they don't have methods or properties, and their equality is determined by their actual value, not their identity.

The sentence suggests that, in TypeScript, you can create a nominal type that represents a very specific and unique value, similar to the concept of a nominal value in JavaScript. This allows you to create stricter type checks and enforce more precise type relationships between variables, leading to more robust and maintainable code.

In summary, nominal types in TypeScript help to create stronger type distinctions, just like nominal values have unique identities in JavaScript.

## 2.9 Understanding Value and Type Namespaces

Bu kısma bir daha bakmak gerekebilir.

Here's the corrected copy-paste as a Markdown-formatted table:

| Declaration type | Type       | Value   |
|------------------|------------|---------|
| Class            | X          | X       |
| Enum             | X          | X       |
| Interface       | X          |         |
| Type Alias       | X          |         |
| Function        |           | X       |
| Variable        |           | X       |

