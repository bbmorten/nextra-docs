# 20230926 Scapy

##  W3Schools Learning

<https://my-learning.w3schools.com>

##  Scapy

```shell
print(p.dst)      # first layer with a dst field, i.e. Ether
print(p[IP].src)  # explicit access to the IP layer src field
```

### sprintf() supports Scapy own formats strings

```shell
print(p.sprintf("%Ether.src% > %Ether.dst%\n%IP.src% > %IP.dst%"))
print(p2.sprintf("%Ether.src% > %Ether.dst%\n%IP.src% > %IP.dst%"))

```

### a field can store many values

```shell
[p for p in IP(ttl=(1,5)) / ICMP()]  # a sequence of values from 1 to 5
```

```shell
[p for p in IP() / TCP(dport=[22, 80, 443])]  # specific values
```

### Interacting with the network

```shell
p = sr1(IP(dst="8.8.8.8")/UDP()/DNS())
p[DNS].an

```

```shell
>>> p[DNS].an
<DNSRR  rrname='www.example.com.' type=A rclass=IN ttl=18886 rdlen=4 rdata=93.184.216.34 |>
>>> list(p)
[<IP  version=4 ihl=5 tos=0x0 len=77 id=58254 flags= frag=0 ttl=56 proto=udp chksum=0x87f4 src=8.8.8.8 dst=192.168.70.101 |<UDP  sport=domain dport=domain len=57 chksum=0x68d7 |<DNS  id=0 qr=1 opcode=QUERY aa=0 tc=0 rd=1 ra=1 z=0 ad=0 cd=0 rcode=ok qdcount=1 ancount=1 nscount=0 arcount=0 qd=<DNSQR  qname='www.example.com.' qtype=A qclass=IN |> an=<DNSRR  rrname='www.example.com.' type=A rclass=IN ttl=18886 rdlen=4 rdata=93.184.216.34 |> ns=None ar=None |>>>]
```

#### the srp() function

- sends a list of frames and returns two variables:
    - r a list of queries and matched answers
    - u a list of unanswered packets

```shell
r, u = srp(Ether()/IP(dst="8.8.8.8", ttl=(5,10))/UDP()/DNS())
```

```shell
# Access the first tuple
print(r[0][0].summary())  # sent packet
print(r[0][1].summary())  # received packet

# Scapy received an ICMP time-exceeded
r[0][1][ICMP]
```

```shell
>>> print(r[0][0].summary()) 
Ether / IP / UDP / DNS Qry "b'www.example.com.'" 
>>> print(r[0][1].summary())
Ether / IP / ICMP 195.2.26.253 > 192.168.70.101 time-exceeded ttl-zero-during-transit / IPerror / UDPerror
>>> r[0][1][ICMP]
<ICMP  type=time-exceeded code=ttl-zero-during-transit chksum=0x56b4 reserved=0 length=0 unused=0 |<IPerror  version=4 ihl=5 tos=0x0 len=61 id=1 flags= frag=0 ttl=1 proto=udp chksum=0xa292 src=192.168.70.101 dst=8.8.8.8 |<UDPerror  sport=domain dport=domain len=41 chksum=0x9db8 |>>>
>>> 
```

#### Writing and reading pcap files

```shell
>>> r, u = srp(Ether() / IP(dst="8.8.8.8", ttl=(5, 10)) / UDP() / DNS())
Begin emission:
Finished sending 6 packets.
.....*....*...*.*.**
Received 20 packets, got 6 answers, remaining 0 packets
>>> wrpcap("IP-UDP-DNS-5-10-TTL.pcap", r)
```

- Read the pcap file and filter IP packets that matches a specific id.

    ```shell
    pcap_2 = rdpcap("capture2.pcap")
    filtered_packets = [packet for packet in pcap_2 if IP in packet and packet[IP].id == 31187]
    wrpcap("IP_id_31187.pcap", filtered_packets)
    ```

- the command() method gives the string that will build the same object

```shell
pcap_2[0].command()
```

- To print packets read from a pcap file in JSON format in Scapy, you can use a combination of Scapy to read the pcap file and Python’s json module to convert the packet information to JSON format.

```python
import json
from scapy.all import PcapReader, Packet

def packet_to_dict(packet: Packet) -> dict:
    """Convert Scapy Packet to Dictionary."""
    packet_dict = {}
    # Iterate over packet layers
    for layer in packet.layers():
        layer_name = layer.__name__
        layer_fields = {}
        # Extract fields from the layer
        for field, value in packet[layer].fields.items():
            if hasattr(value, 'fields'):  # This value is another layer
                layer_fields[field] = packet_to_dict(value)
            else:
                layer_fields[field] = value
        packet_dict[layer_name] = layer_fields
    return packet_dict


def main():
    # Read packets from pcap file in a memory-efficient manner
    with PcapReader('filename.pcap') as pcap_reader:
        for packet in pcap_reader:
            packet_dict = packet_to_dict(packet)
            packet_json = json.dumps(packet_dict, indent=4)
            print(packet_json)


if __name__ == "__main__":
    main()

```

#### lambda function in sniff

```python
>>> s = sniff(count=100, prn=lambda p: p.summary())
Ether / IP / TCP 149.154.167.91:https > 192.168.70.101:63235 PA / Raw
Ether / IP / TCP 192.168.70.101:63235 > 149.154.167.91:https A
Ether / IP / TCP 149.154.167.91:https > 192.168.70.101:63235 PA / Raw
Ether / IP / TCP 192.168.70.101:63235 > 149.154.167.91:https A
Ether / IP / TCP 216.58.213.106:https > 192.168.70.101:54037 PA / Raw
Ether / IP / TCP 192.168.70.101:54037 > 216.58.213.106:https A
Ether / IP / TCP 192.168.70.101:63235 > 149.154.167.91:https PA / Raw
Ether / IP / TCP 149.154.167.91:https > 192.168.70.101:63235 PA / Raw
Ether / IP / TCP 192.168.70.101:63235 > 149.154.167.91:https A
Ether / IP / TCP 149.154.167.91:https > 192.168.70.101:63235 PA / Raw
Ether / IP / TCP 192.168.70.101:63235 > 149.154.167.91:https A
Ether / IP / TCP 192.168.70.101:63235 > 149.154.167.91:https PA / Raw
Ether / IP / UDP / DNS Qry "b'_companion-link._tcp.local.'" 
Ether / IP / TCP 149.154.167.91:https > 192.168.70.101:63235 PA / Raw
Ether / IP / TCP 192.168.70.101:63235 > 149.154.167.91:https A
...
```

###  What is raw in the outputs?

In the context of Scapy and network packet analysis, `Raw` refers to the payload of the packet that is not interpreted or decoded as any of the higher-level protocol layers. Essentially, it’s the part of the packet that Scapy doesn’t recognize as another protocol layer, and it's left as raw bytes.

When Scapy parses packets, it peels off the layers one by one, interpreting each according to known protocol formats like Ethernet, IP, TCP, etc. If Scapy encounters payload data that it can't interpret as a known protocol, it classifies this data as `Raw`.

For example, if you have a TCP packet that carries HTTP data, and Scapy doesn’t parse the HTTP data, then that HTTP data will be in the `Raw` layer of the Scapy packet.

Here is a brief example:

```python
from scapy.all import Ether, IP, TCP, Raw

# Crafting a packet with Raw payload
packet = Ether() / IP() / TCP() / Raw(load="Some raw bytes")

# Displaying the packet
packet.show()
```

In this example, the string `"Some raw bytes"` is the payload that is classified as `Raw` by Scapy, as it doesn't correspond to any known protocol layer that comes after the TCP layer in this packet.
