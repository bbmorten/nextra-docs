# 20230729-30072023 - RxJs Getting Started Postponed

## /Users/bulent/git-repos/personallog/2807202301/src

Moved to "/Users/bulent/git-repos/typescript-ws/my-ts-course/src". All other files were deleted.

##  Typescript project initialization - ESLint

```shell
npm install -g eslint
npm install eslint @typescript-eslint/eslint-plugin @typescript-eslint/parser --save-dev

npx eslint --init
# or
npm init @eslint/config
```

Add the following lines to your .vscode/settings.json

```json
"eslint.validate": [
    "javascript",
    "typescript"
],
"eslint.options": {
    "parser": "@typescript-eslint/parser"
},
```

```console
tsc --init
tsc -w

node main.js
```

## Typescript project initialization

```console
npm init -y
npm install -D typescript
npx tsc --init
mkdir -p src dist
```

Add the following lines to your tsconfig.json

```json
{
  "compilerOptions": {
    //...
    "rootDir": "./src",
    "outDir": "./dist"
  }
}
```

Create a index.ts file with any code and run `npx tsc`. Check the ***dist*** folder.

'*.ts' files will be converted to '*.js' files.

You can use also **tsc -w**. Watch over the ***src*** folder and convert them to .js files automatically.

### Installing React

```console
npm install --save react

```

### Installing Type Definitions

```console
npm install --save-dev @types/react

```

### Backend Server project folder with different tsconfig.json

Bu kısım patladı. Daha doğrusu ```npx tsc -p server/tsconfig.json``` komutunun faydasını görmedik.
Client ve sunucu kodun aynı anda yazılması ortak tsconfig.json kullanılması vs konularına bakmak lazım.
Kitapta shared tsconfig.json kullanılması ile ilgili tavsiye var.
Module 1.6

```console
mkdir server
cd server
npm init -y
mkdir -p src dist
npx tsc --init
npm install --save express
npm install -D @types/express @types/node
```

Replace the contents of tsconfig.json with the following content.

```json
{
  "compilerOptions": {
    "target": "ESNext",
    "lib": [
      "ESNext"
    ],
    "module": "commonjs",
    "rootDir": "./src",
    "moduleResolution": "node",
    "types": [
      "node"
    ],
    "outDir": "./dist",
    "esModuleInterop": true,
    "forceConsistentCasingInFileNames": true,
    "strict": true,
    "skipLibCheck": true
  }
}
```

index.js dosyasını ***src*** folder altında yarattık. ```node index.js``` ile çalıştırdık.

```javascript
const http = require("http"); // 1

const hostname = "127.0.0.1";
const port = process.env.PORT || 3000; // 2

const server = http.createServer((req, res) => {
  res.statusCode = 200;
  res.setHeader("Content-Type", "text/plain");
  res.end("Hello World");
});

server.listen(port, hostname, () => {
  console.log(`Server running at http://${hostname}:${port}/`); // 3
});

```

## Another javascript framework Deno

[Deno](https://deno.land/manual@v1.35.3/getting_started/setup_your_environment)

##  Recommended tsconfig bases (Important)

Recommended [tsconfig bases](https://github.com/tsconfig/bases)

## Basic Types

###  Annotating Effectively

```typescript
// Type annotation
let anotherNumber: number = 3;

type Person = {
  name: string;
  age: number;
};

const me: Person = createPerson();

function createPerson(): Person {
  return { name: "Stefan", age: 39 };
}

```

/Users/bulent/git-repos/typescript-ws/my-ts-course-2/main.ts
/Users/bulent/git-repos/typescript-ws/my-ts-course-2/annotating.ts

### Any vs unknown

/Users/bulent/git-repos/typescript-ws/my-ts-course-2/anyvsunknown.ts

### Choosing the right object type

Typescript Types <https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781098136642/files/assets/tscb_0201.png>

###  let, var and const

GitHub Copilot: `let`, `var`, and `const` are all used to declare variables in JavaScript and TypeScript, but they have some differences in their behavior.

`var` is the oldest way to declare variables in JavaScript. It has function scope, which means that a variable declared with `var` is accessible within the function it is declared in, as well as any nested functions. If a variable is declared with `var` outside of any function, it becomes a global variable. `var` variables can be redeclared and reassigned.

`let` and `const` were introduced in ES6 (ECMAScript 2015) and have block scope, which means that a variable declared with `let` or `const` is only accessible within the block it is declared in (a block is anything between curly braces `{}`). `let` variables can be reassigned, but not redeclared. `const` variables cannot be reassigned or redeclared.

Here is an example:

```typescript
function example() {
  var x = 1;
  let y = 2;
  const z = 3;

  if (true) {
    var x = 4; // This reassigns the value of x
    let y = 5; // This declares a new variable y with block scope
    const z = 6; // This declares a new variable z with block scope
    console.log(x, y, z); // Output: 4 5 6
  }

  console.log(x, y, z); // Output: 4 2 3
}

example();
```

In this example, `var x` is accessible within the entire function, so when it is reassigned inside the `if` block, it affects the value of `x` outside of the block. `let y` and `const z` are only accessible within their respective blocks, so when they are declared again inside the `if` block, they do not affect the values of `y` and `z` outside of the block.

###  let, var and const best practices

GitHub Copilot: Here are some best practices for using `let`, `var`, and `const` in TypeScript:

1. Use `const` by default: If you know that a variable's value will not change, use `const` to declare it. This helps prevent accidental reassignment and makes your code more readable.

2. Use `let` when you need to reassign a variable: If you know that a variable's value will change, use `let` to declare it. This makes it clear that the variable's value is mutable.

3. Avoid using `var`: `var` has function scope, which can lead to unexpected behavior. Instead, use `let` or `const`, which have block scope.

4. Declare variables as close to their first use as possible: This makes it easier to understand the variable's purpose and reduces the risk of naming conflicts.

5. Use meaningful variable names: Use descriptive names that make it clear what the variable represents. Avoid using single-letter variable names, except for loop counters.

6. Use type annotations: Use type annotations to make it clear what type of data the variable holds. This can help prevent bugs and make your code more readable.

Here's an example of how you could apply these best practices to the code you provided:

```typescript
function example() {
  const initialX = 1;
  let y = 2;
  const z = 3;
  let w = 5;

  if (true) {
    const x = 4;
    w = 4;
    let innerY = 5;
    const innerZ = 6;
    console.log(x, innerY, innerZ, w);
  }

  console.log(initialX, y, z, w);
}

example();
```

In this example, we've used `const` for `initialX` and `z` because their values don't change, and `let` for `y` and `w` because their values do change. We've also used meaningful variable names and added type annotations where appropriate. Finally, we've avoided using `var` and declared variables as close to their first use as possible.

###  Object creation

GitHub Copilot: In JavaScript, there are three different ways to create objects: using the `Object` constructor, using object literals (`{}`), and using the `object` keyword. However, all three of these methods create objects of the same type: the `Object` type.

Therefore, it doesn't matter which method you use to create an object in TypeScript. You can use any of the three methods to create an object, and TypeScript will treat them all as instances of the `Object` type.

Here's an example:

```typescript
const obj1 = new Object(); // Using the Object constructor
const obj2 = {}; // Using an object literal
const obj3: object = {}; // Using the object keyword

console.log(typeof obj1); // Output: object
console.log(typeof obj2); // Output: object
console.log(typeof obj3); // Output: object
```

In this example, `obj1`, `obj2`, and `obj3` are all instances of the `Object` type, even though they were created using different methods.

###  Working with tuples

```typescript title='Working with tuples'
{% include "./workingwTuples.ts" %}


```

####  Array definitions

GitHub Copilot: Sure! Here are some examples of how to define arrays in TypeScript:

```typescript
// Define an array of numbers
const numbers: number[] = [1, 2, 3, 4, 5];

// Define an array of strings
const strings: string[] = ["hello", "world"];

// Define an array of booleans
const booleans: boolean[] = [true, false, true];

// Define an array of objects
interface Person {
  name: string;
  age: number;
}

const people: Person[] = [
  { name: "Alice", age: 30 },
  { name: "Bob", age: 40 },
  { name: "Charlie", age: 50 },
];

// Define an array of mixed types
const mixed: (string | number | boolean)[] = ["hello", 42, true];
```

In these examples, we use the square bracket syntax to define an array of a specific type. The type is specified inside the brackets, followed by the `[]` array notation.

You can also use the `Array<elementType>` syntax to define an array, like this:

```typescript
const numbers: Array<number> = [1, 2, 3, 4, 5];
```

This is equivalent to the `number[]` syntax.

### Destructuring an array

GitHub Copilot: Sure! You can use array destructuring to achieve this. Here's an example:

```typescript
const array1 = [1, 2, 3, 4, 5, 6];
const [x, y, z, ...rest] = array1;

console.log(x); // Output: 1
console.log(y); // Output: 2
console.log(z); // Output: 3
console.log(rest); // Output: [4, 5, 6]
```

In this example, we declare an array `array1` with six elements. We then use array destructuring to assign the first three elements of `array1` to variables `x`, `y`, and `z`, respectively. The `...rest` syntax is used to assign the remaining elements of `array1` to a new array called `rest`.

You can modify this example to fit your specific use case. Just replace `array1` with your own array variable name and adjust the variable names as needed.

###  Iterating through an array

```typescript
// Define an array of objects
interface PersonW {
  name: string;
  age: number;
}

const people: PersonW[] = [
  { name: "Alice", age: 30 },
  { name: "Bob", age: 40 },
  { name: "Charlie", age: 50 },
];

console.log(people)

// Printing array elements with for loop

for (let index = 0; index < people.length; index++) {
    const element = people[index];
    console.log(element, typeof element)
    
}

// Printing array elements with foreach loop


people.forEach(element => {
    console.log(element, typeof element);

});


for (const key in people) {
    if (Object.prototype.hasOwnProperty.call(people, key)) {
        const element = people[key];
        console.log(element, typeof element);

        
    }
}

for (const iterator of people) {
    console.log(iterator, typeof iterator)
}
```

##  history command

In the Linux terminal, the `history` command is used to display a list of previously executed commands along with their line numbers. If you want to remove the line numbers from the output of the `history` command, you can do so by using the `cut` command or the `awk` command to process the output and eliminate the line numbers. Here's how you can achieve that using both methods:

Method 1: Using `cut` command

```bash
history | cut -c 8-
```

Explanation:

- The `history` command displays the command history with line numbers.
- The `cut` command is used to remove characters from each line of a file. In this case, we use `-c 8-` to cut out characters starting from the 8th character of each line, effectively removing the line numbers.

Method 2: Using `awk` command

```bash
history | awk '{$1=""; print $0}'
```

Explanation:

- The `history` command outputs the command history with line numbers.
- The `awk` command is a powerful text processing tool. Here, we use it to remove the first field (i.e., the line number) from each line and then print the entire line without the line number.

Both of these commands will display the command history without the line numbers. Choose the method that suits your preference or the one that you find more convenient.
